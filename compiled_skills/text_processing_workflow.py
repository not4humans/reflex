"""
Compiled skill: Text Processing Workflow
Generated by Agentic Skill Compiler - Demo Skill for Phase 6 Testing

This skill demonstrates the compiled skill format and execution pattern.
"""

import asyncio
from typing import Any, Dict

# Skill metadata for registry
SKILL_METADATA = {
    "skill_id": "text_processing_workflow_demo",
    "name": "text_processing_workflow",
    "description": "Transform text and write to file - optimized workflow",
    "pattern": ["string_transform", "write_file"],
    "parameters": ["input_text", "operation", "output_file"],
    "strategy": "python_macro",
    "confidence": 0.85,
    "estimated_cost_reduction": 0.25,
    "success_rate": 0.90,
    "avg_cost": 0.15,
    "avg_latency_ms": 120.0,
    "created_at": "2024-12-24T15:30:00",
    "source_pattern_id": "pattern_text_processing_001"
}


async def text_processing_workflow(input_text: str = "hello world", 
                                 operation: str = "uppercase", 
                                 output_file: str = "output.txt") -> Dict[str, Any]:
    """
    Compiled skill that performs text transformation and file writing.
    
    This skill demonstrates the typical pattern of:
    1. Transform text with some operation
    2. Write the result to a file
    
    Args:
        input_text: The text to process
        operation: Type of transformation (uppercase, lowercase, reverse, etc.)
        output_file: File to write the result to
        
    Returns:
        Dict with execution results
    """
    
    # Simulate the original string_transform tool
    await asyncio.sleep(0.05)  # Simulate processing time
    
    if operation == "uppercase":
        transformed = input_text.upper()
    elif operation == "lowercase":
        transformed = input_text.lower()
    elif operation == "reverse":
        transformed = input_text[::-1]
    elif operation == "capitalize":
        transformed = input_text.capitalize()
    else:
        transformed = input_text  # No-op for unknown operations
    
    # Simulate the write_file tool
    await asyncio.sleep(0.03)  # Simulate file I/O
    
    try:
        # In a real implementation, this would actually write to disk
        # For demo purposes, we'll simulate successful file writing
        file_content = f"Processed text: {transformed}\\nOperation: {operation}\\nTimestamp: {asyncio.get_event_loop().time()}"
        
        # Simulate file write success
        result = {
            "success": True,
            "transformed_text": transformed,
            "output_file": output_file,
            "original_text": input_text,
            "operation": operation,
            "file_size": len(file_content),
            "message": f"Successfully processed '{input_text}' -> '{transformed}' and saved to {output_file}"
        }
        
        return result
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "original_text": input_text,
            "operation": operation,
            "output_file": output_file
        }


# For testing the skill directly
async def main():
    """Test the compiled skill."""
    print("üß™ Testing compiled skill: text_processing_workflow")
    
    test_cases = [
        {"input_text": "Hello World", "operation": "uppercase", "output_file": "test1.txt"},
        {"input_text": "Python Rocks", "operation": "lowercase", "output_file": "test2.txt"},
        {"input_text": "Reverse Me", "operation": "reverse", "output_file": "test3.txt"},
    ]
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\\n--- Test {i} ---")
        print(f"Input: {test_case}")
        
        result = await text_processing_workflow(**test_case)
        
        if result["success"]:
            print(f"‚úÖ Success: {result['message']}")
        else:
            print(f"‚ùå Failed: {result['error']}")


if __name__ == "__main__":
    asyncio.run(main())
