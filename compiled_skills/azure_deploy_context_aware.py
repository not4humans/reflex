"""
Context-Aware Azure Deployment Skill
Generated by Agentic Skill Compiler with Context Analysis

This skill demonstrates context-sensitive execution for cloud deployment.
"""

import asyncio
import subprocess
import os
from typing import Any, Dict, List

# Enhanced skill metadata with context awareness
SKILL_METADATA = {
    "skill_id": "azure_deploy_context_aware",
    "name": "azure_deploy_with_context",
    "description": "Deploy application to Azure with context-aware adaptations",
    "pattern": ["azure_login", "azure_deploy"],
    "parameters": ["app_path", "resource_group", "app_name"],
    "strategy": "python_macro",
    "confidence": 0.92,
    "estimated_cost_reduction": 0.35,
    "success_rate": 0.95,
    "avg_cost": 0.25,
    "avg_latency_ms": 2500.0,
    "created_at": "2025-08-05T12:00:00",
    "source_pattern_id": "pattern_azure_deploy_001",
    
    # Context-aware enhancements
    "success_conditions": {
        "authentication": ["azure_cli_logged_in=true"],
        "prerequisites": ["resource_group_exists=true", "app_path_valid=true"],
        "resources": ["disk_space_sufficient=true"],
        "connectivity": ["network_stable=true"]
    },
    "context_adaptations": {
        "if_not_authenticated": "force_login_with_device_code",
        "if_resource_group_missing": "create_resource_group_first", 
        "if_path_invalid": "validate_and_fix_path",
        "if_network_unstable": "retry_with_exponential_backoff",
        "if_insufficient_permissions": "escalate_or_use_alternate_approach"
    },
    "failure_patterns": {
        "network_unstable=true": {"failure_rate": 0.8, "confidence": 0.6},
        "disk_space_low=true": {"failure_rate": 0.9, "confidence": 0.8},
        "cli_not_authenticated=true": {"failure_rate": 1.0, "confidence": 0.95}
    }
}


async def azure_deploy_with_context(app_path: str = "./app", 
                                  resource_group: str = "my-rg",
                                  app_name: str = "my-app",
                                  execution_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Context-aware Azure deployment skill.
    
    This skill adapts its execution based on environmental context,
    mimicking how humans adjust their approach based on situational awareness.
    
    Args:
        app_path: Path to application code
        resource_group: Azure resource group name
        app_name: Application name
        execution_context: Environmental context for adaptive execution
        
    Returns:
        Dict with execution results and context adaptations applied
    """
    
    context = execution_context or {}
    adaptations_applied = []
    
    try:
        # PHASE 1: Context Assessment & Adaptation
        print(f"🔍 Assessing execution context...")
        
        # Check authentication status
        if not context.get('azure_cli_logged_in', False):
            print(f"🔑 Authentication required - applying adaptation")
            await _handle_authentication_required()
            adaptations_applied.append("authentication_fixed")
        
        # Check resource group existence
        if not context.get('resource_group_exists', False):
            print(f"📦 Resource group missing - creating...")
            await _ensure_resource_group_exists(resource_group)
            adaptations_applied.append("resource_group_created")
        
        # Validate application path
        if not context.get('app_path_valid', False) or not os.path.exists(app_path):
            print(f"📁 Invalid app path - validating...")
            app_path = await _validate_and_fix_path(app_path)
            adaptations_applied.append("path_validated")
        
        # Check for failure-prone conditions
        if context.get('network_unstable', False):
            print(f"🌐 Unstable network detected - enabling retry logic")
            adaptations_applied.append("retry_logic_enabled")
        
        if context.get('disk_space_low', False):
            print(f"💾 Low disk space - cleaning up before deployment")
            await _cleanup_temp_files()
            adaptations_applied.append("disk_cleanup_performed")
        
        # PHASE 2: Adaptive Execution
        print(f"🚀 Starting adaptive deployment...")
        
        # Simulate Azure CLI login (adapted based on context)
        login_start = asyncio.get_event_loop().time()
        if context.get('network_unstable', False):
            # Use slower but more reliable method
            await asyncio.sleep(0.3)  # Simulate retry logic
        else:
            await asyncio.sleep(0.1)  # Normal login
        login_time = (asyncio.get_event_loop().time() - login_start) * 1000
        
        # Simulate deployment (adapted based on context)
        deploy_start = asyncio.get_event_loop().time()
        if context.get('large_app_size', False):
            await asyncio.sleep(0.5)  # Longer for large apps
        else:
            await asyncio.sleep(0.2)  # Normal deployment
        deploy_time = (asyncio.get_event_loop().time() - deploy_start) * 1000
        
        # PHASE 3: Success with Context Tracking
        result = {
            "success": True,
            "app_name": app_name,
            "resource_group": resource_group,
            "app_path": app_path,
            "deployment_url": f"https://{app_name}.azurewebsites.net",
            "execution_time_ms": login_time + deploy_time,
            
            # Context-aware execution results
            "adaptations_applied": adaptations_applied,
            "context_handled": len(adaptations_applied) > 0,
            "execution_context": context,
            "context_confidence": _calculate_context_confidence(context, adaptations_applied),
            
            "message": f"Successfully deployed {app_name} with {len(adaptations_applied)} context adaptations"
        }
        
        return result
        
    except Exception as e:
        # Enhanced error handling with context
        return {
            "success": False,
            "error": str(e),
            "app_name": app_name,
            "resource_group": resource_group,
            "adaptations_applied": adaptations_applied,
            "context_at_failure": context,
            "suggested_fix": _suggest_context_fix(context, str(e))
        }


async def _handle_authentication_required():
    """Handle authentication requirements contextually."""
    print("  🔐 Initiating device code authentication...")
    await asyncio.sleep(0.15)  # Simulate auth process


async def _ensure_resource_group_exists(resource_group: str):
    """Ensure resource group exists, create if needed."""
    print(f"  📦 Creating resource group: {resource_group}")
    await asyncio.sleep(0.1)  # Simulate RG creation


async def _validate_and_fix_path(app_path: str) -> str:
    """Validate and potentially fix application path."""
    print(f"  📁 Validating path: {app_path}")
    await asyncio.sleep(0.05)
    
    # For demo, just return a valid-looking path
    if not app_path or app_path == "./app":
        return "./demo-app"
    return app_path


async def _cleanup_temp_files():
    """Clean up temporary files to free disk space."""
    print("  🧹 Cleaning up temporary files...")
    await asyncio.sleep(0.08)


def _calculate_context_confidence(context: Dict[str, Any], adaptations: List[str]) -> float:
    """Calculate confidence based on context handling."""
    base_confidence = 0.7
    
    # Boost confidence for successful adaptations
    adaptation_boost = len(adaptations) * 0.05
    
    # Reduce confidence for risky conditions
    risk_penalty = 0.0
    if context.get('network_unstable', False):
        risk_penalty += 0.1
    if context.get('disk_space_low', False):
        risk_penalty += 0.15
    
    return min(0.95, max(0.5, base_confidence + adaptation_boost - risk_penalty))


def _suggest_context_fix(context: Dict[str, Any], error: str) -> str:
    """Suggest fixes based on context and error."""
    if "authentication" in error.lower():
        return "Run 'az login' to authenticate Azure CLI"
    elif "resource" in error.lower():
        return "Check resource group permissions and existence"
    elif "network" in error.lower():
        return "Check network connectivity and try again"
    elif "space" in error.lower():
        return "Free up disk space and retry deployment"
    else:
        return "Check Azure CLI configuration and permissions"


# Demo/testing function
async def main():
    """Test the context-aware deployment skill."""
    print("🧪 Testing Context-Aware Azure Deployment Skill")
    print("=" * 60)
    
    test_scenarios = [
        {
            "name": "Ideal Conditions",
            "context": {
                "azure_cli_logged_in": True,
                "resource_group_exists": True,
                "app_path_valid": True,
                "network_stable": True,
                "disk_space_sufficient": True
            }
        },
        {
            "name": "Authentication Required",
            "context": {
                "azure_cli_logged_in": False,
                "resource_group_exists": True,
                "app_path_valid": True,
                "network_stable": True
            }
        },
        {
            "name": "Multiple Issues",
            "context": {
                "azure_cli_logged_in": False,
                "resource_group_exists": False,
                "app_path_valid": False,
                "network_unstable": True,
                "disk_space_low": True
            }
        }
    ]
    
    for i, scenario in enumerate(test_scenarios, 1):
        print(f"\n--- Scenario {i}: {scenario['name']} ---")
        print(f"Context: {scenario['context']}")
        
        result = await azure_deploy_with_context(
            app_path="./test-app",
            resource_group="test-rg", 
            app_name=f"test-app-{i}",
            execution_context=scenario['context']
        )
        
        if result["success"]:
            print(f"✅ {result['message']}")
            print(f"   Adaptations: {result['adaptations_applied']}")
            print(f"   Context confidence: {result['context_confidence']:.1%}")
        else:
            print(f"❌ Failed: {result['error']}")
            print(f"   Suggested fix: {result['suggested_fix']}")


if __name__ == "__main__":
    asyncio.run(main())
